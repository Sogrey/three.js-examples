<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="使用统一接口加载多种格式的3D模型，包括GLTF、OBJ、FBX、STL等">
    <meta name="three-version" content="r179">
    <title>Three.js 示例 - 多格式模型加载器</title>
    <link rel="stylesheet" href="../css/example-common.css">
</head>
<body>
    <!-- 3D场景容器 -->
    <div class="three-container" id="threeContainer"></div>
    
    <!-- 使用importmap定义模块导入映射 -->
    <script type="importmap">
        {
            "imports": {
                "three": "../libs/three/r179/build/three.module.js",
                "three/addons/": "../libs/three/r179/jsm/"
            }
        }
    </script>
    
    <!-- 示例代码 -->
    <script type="module">
        // 导入Three.js、控制器、GUI和模型加载器
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import modelLoader from '../js/ModelLoader.js';

        // Three.js 核心变量 - 暴露给全局作用域以便截图功能使用
        window.scene = null;
        window.camera = null;
        window.renderer = null;
        
        // 场景、控制器和其他变量
        let controls;
        let currentModel = null;
        let mixer = null;
        let clock = new THREE.Clock();
        let isLoading = false;
        let gui;
        let loadingElement;

        // 模型配置
        const modelConfigs = {
            stl: {
                url: '../models/stl/ascii/pr2_head_pan.stl',
                type: 'STL',
                options: {
                    scale: { x: 0.1, y: 0.1, z: 0.1 },
                    rotation: { x: 0, y: 0, z: 0 },
                    color: 0x00aaff
                },
                name: 'STL 机器人头部'
            },
            gltf: {
                url: '../models/gltf/LeePerrySmith/LeePerrySmith.glb',
                type: 'GLTF',
                options: {
                    scale: { x: 1, y: 1, z: 1 },
                    rotation: { x: 0, y: 0, z: 0 }
                },
                name: 'GLTF 人头模型'
            },
            obj: {
                url: '../models/obj/male02/male02.obj',
                type: 'OBJ',
                options: {
                    scale: { x: 0.1, y: 0.1, z: 0.1 },
                    rotation: { x: 0, y: 0, z: 0 },
                    material: {
                        url: '../models/obj/male02/male02.mtl',
                        type: 'MTL'
                    }
                },
                name: 'OBJ 男性模型'
            },
            fbx: {
                url: '../models/fbx/monkey.fbx',
                type: 'FBX',
                options: {
                    scale: { x: 0.05, y: 0.05, z: 0.05 },
                    rotation: { x: 0, y: 0, z: 0 }
                },
                name: 'FBX 猴子模型'
            },
            pcd: {
                url: '../models/pcd/ascii/simple.pcd',
                type: 'PCD',
                options: {
                    scale: { x: 0.1, y: 0.1, z: 0.1 },
                    rotation: { x: 0, y: 0, z: 0 }
                },
                name: 'PCD 点云模型'
            },
            // 暂时禁用BVH，因为加载卡住
            /*bvh: {
                url: '../models/bvh/pirouette.bvh',
                type: 'BVH',
                options: {
                    scale: { x: 0.1, y: 0.1, z: 0.1 },
                    rotation: { x: 0, y: 0, z: 0 },
                    playAnimation: true
                },
                name: 'BVH 骨骼动画'
            },*/
            '3ds': {
                url: '../models/3ds/portalgun/portalgun.3ds',
                type: '3DS',
                options: {
                    scale: { x: 0.05, y: 0.05, z: 0.05 },
                    rotation: { x: 0, y: 0, z: 0 }
                },
                name: '3DS 传送门枪'
            },
            dae: {
                url: '../models/collada/elf/elf.dae',
                type: 'DAE',
                options: {
                    scale: { x: 0.02, y: 0.02, z: 0.02 },
                    rotation: { x: 0, y: 0, z: 0 }
                },
                name: 'DAE/COLLADA 精灵'
            },
            // 暂时禁用JSON，因为找不到合适的模型文件
            // json: {
            //     url: '../models/json/suzanne_buffergeometry.json',
            //     type: 'JSON',
            //     options: {
            //         scale: { x: 0.3, y: 0.3, z: 0.3 },
            //         rotation: { x: 0, y: 0, z: 0 }
            //     },
            //     name: 'JSON 茶壶模型'
            // },
            wrl: {
                url: '../models/vrml/meshWithTexture.wrl',
                type: 'WRL',
                options: {
                    scale: { x: 0.1, y: 0.1, z: 0.1 },
                    rotation: { x: 0, y: 0, z: 0 }
                },
                name: 'VRML'
            },
            vtk: {
                url: '../models/vtk/liver.vtk',
                type: 'VTK',
                options: {
                    scale: { x: 0.1, y: 0.1, z: 0.1 },
                    rotation: { x: 0, y: 0, z: 0 },
                    color: 0xff5533,  // 肝脏颜色设为红色系
                    metalness: 0.0,    
                    roughness: 0.7,    
                    emissive: 0x222222 
                },
                name: 'VTK 肝脏模型'
            },
            kmz: {
                url: '../models/kmz/Box.kmz',
                type: 'KMZ',
                options: {
                    scale: { x: 1, y: 1, z: 1 },
                    rotation: { x: 0, y: 0, z: 0 }
                },
                name: 'KMZ 盒子模型'
            },
            amf: {
                url: '../models/amf/rook.amf',
                type: 'AMF',
                options: {
                    scale: { x: 1, y: 1, z: 1 },
                    rotation: { x: 0, y: 0, z: 0 }
                },
                name: 'AMF 城堡模型'
            },
            gcode: {
                url: '../models/gcode/benchy.gcode',
                type: 'GCODE',
                options: {
                    scale: { x: 1, y: 1, z: 1 },
                    rotation: { x: 0, y: 0, z: 0 }
                },
                name: 'GCODE 小船模型'
            }
        };

        // 模型类型数组，用于切换
        const modelTypes = Object.keys(modelConfigs);
        let currentModelIndex = 0;

        // GUI参数
        const params = {
            modelType: 'stl',
            backgroundColor: 0x222222,
            showGrid: true,
            resetCamera: function() {
                resetCamera();
            },
            nextModel: function() {
                loadNextModel();
            },
            prevModel: function() {
                loadPrevModel();
            }
        };

        // 初始化场景
        init();
        
        // 动画循环
        animate();

        /**
         * 初始化Three.js场景、相机、渲染器和控制器
         */
        function init() {
            // 创建加载提示元素
            createLoadingElement();
            
            // 创建场景
            window.scene = new THREE.Scene();
            window.scene.background = new THREE.Color(params.backgroundColor);

            // 创建相机
            window.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            window.camera.position.set(0, 5, 10);

            // 创建渲染器
            window.renderer = new THREE.WebGLRenderer({ antialias: true });
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            window.renderer.setPixelRatio(window.devicePixelRatio);
            window.renderer.shadowMap.enabled = true;
            document.getElementById('threeContainer').appendChild(window.renderer.domElement);

            // 创建控制器
            controls = new OrbitControls(window.camera, window.renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 添加灯光
            addLights();

            // 添加地面网格
            addGround();

            // 创建GUI
            createGUI();

            // 添加事件监听器
            window.addEventListener('resize', onWindowResize);

            // 默认加载STL模型
            loadModel(params.modelType);
        }
        
        /**
         * 创建加载提示元素
         */
        function createLoadingElement() {
            loadingElement = document.createElement('div');
            loadingElement.style.position = 'absolute';
            loadingElement.style.top = '50%';
            loadingElement.style.left = '50%';
            loadingElement.style.transform = 'translate(-50%, -50%)';
            loadingElement.style.color = 'white';
            loadingElement.style.fontSize = '24px';
            loadingElement.style.textShadow = '1px 1px 1px rgba(0,0,0,0.8)';
            loadingElement.style.display = 'none';
            loadingElement.textContent = '加载中...';
            document.body.appendChild(loadingElement);
        }

        /**
         * 创建GUI控制面板
         */
        function createGUI() {
            gui = new GUI({ title: '模型加载器控制面板', width: 300 });
            
            // 调整GUI位置
            gui.domElement.style.position = 'absolute';
            gui.domElement.style.top = '60px';
            gui.domElement.style.right = '10px';
            
            // 确保GUI在所有环境下都可见
            gui.domElement.style.zIndex = '1000';
            
            // 模型选择
            const modelOptions = {};
            modelTypes.forEach(type => {
                modelOptions[modelConfigs[type].name] = type;
            });
            
            gui.add(params, 'modelType', modelOptions).name('选择模型').onChange(value => {
                loadModel(value);
            });
            
            // 背景颜色
            const bgColors = {
                '深灰色': 0x222222,
                '黑色': 0x000000,
                '白色': 0xffffff,
                '深蓝色': 0x0a0a2a,
                '深绿色': 0x1a472a
            };
            
            gui.add(params, 'backgroundColor', bgColors).name('背景颜色').onChange(value => {
                window.scene.background = new THREE.Color(value);
            });
            
            // 显示/隐藏网格
            gui.add(params, 'showGrid').name('显示网格').onChange(value => {
                window.scene.children.forEach(child => {
                    if (child instanceof THREE.GridHelper) {
                        child.visible = value;
                    }
                });
            });
            
            // 控制按钮
            const controlsFolder = gui.addFolder('控制');
            controlsFolder.add(params, 'resetCamera').name('重置相机');
            controlsFolder.add(params, 'prevModel').name('上一个模型');
            controlsFolder.add(params, 'nextModel').name('下一个模型');
            
            controlsFolder.open();
        }

        /**
         * 添加灯光
         */
        function addLights() {
            // 环境光 - 增强环境光强度
            const ambientLight = new THREE.AmbientLight(0x606060, 1.5);
            window.scene.add(ambientLight);

            // 方向光 - 增加多个方向光，从不同角度照亮模型
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight1.position.set(1, 1, 1);
            directionalLight1.castShadow = true;
            directionalLight1.shadow.mapSize.width = 2048;
            directionalLight1.shadow.mapSize.height = 2048;
            window.scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(-1, 0.5, -1);
            window.scene.add(directionalLight2);

            // 半球光
            const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.7);
            window.scene.add(hemisphereLight);
            
            // 添加点光源，更好地照亮模型
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(0, 5, 0);
            window.scene.add(pointLight);
        }

        /**
         * 添加地面
         */
        function addGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            window.scene.add(ground);

            // 添加网格辅助
            const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
            gridHelper.position.y = -1.99;
            window.scene.add(gridHelper);
        }

        /**
         * 加载下一个模型
         */
        function loadNextModel() {
            currentModelIndex = (currentModelIndex + 1) % modelTypes.length;
            const modelType = modelTypes[currentModelIndex];
            params.modelType = modelType;
            
            // 更新GUI
            for (const controller of gui.controllers) {
                if (controller.property === 'modelType') {
                    controller.updateDisplay();
                    break;
                }
            }
            
            loadModel(modelType);
        }

        /**
         * 加载上一个模型
         */
        function loadPrevModel() {
            currentModelIndex = (currentModelIndex - 1 + modelTypes.length) % modelTypes.length;
            const modelType = modelTypes[currentModelIndex];
            params.modelType = modelType;
            
            // 更新GUI
            for (const controller of gui.controllers) {
                if (controller.property === 'modelType') {
                    controller.updateDisplay();
                    break;
                }
            }
            
            loadModel(modelType);
        }

        /**
         * 加载模型
         */
        function loadModel(modelType) {
            if (isLoading) return;
            isLoading = true;

            // 显示加载提示
            loadingElement.style.display = 'block';

            // 移除当前模型
            if (currentModel) {
                window.scene.remove(currentModel);
                currentModel = null;
            }

            // 获取模型配置
            const config = modelConfigs[modelType];
            currentModelIndex = modelTypes.indexOf(modelType);

            // 加载模型
            modelLoader.load(
                config.url,
                config.type,
                config.options,
                (object) => {
                    // 加载成功
                    currentModel = object;
                    window.scene.add(currentModel);

                    // 居中模型
                    centerModel(currentModel);

                    // 处理动画
                    if (object.animations && object.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(object);
                        const action = mixer.clipAction(object.animations[0]);
                        action.play();
                    }

                    // 隐藏加载提示
                    loadingElement.style.display = 'none';
                    isLoading = false;
                    
                    // 更新标题信息
                    document.title = `Three.js 示例 - 多格式模型加载器`;
                },
                (xhr) => {
                    // 加载进度
                    if (xhr.lengthComputable && xhr.total > 0) {
                        const percent = Math.round((xhr.loaded / xhr.total) * 100);
                        console.log(`${percent}% 已加载`);
                    } else {
                        console.log(`已加载 ${(xhr.loaded / 1024).toFixed(2)} KB`);
                    }
                },
                (error) => {
                    // 加载错误
                    console.error('模型加载失败:', error);
                    loadingElement.style.display = 'none';
                    isLoading = false;
                }
            );
        }

        /**
         * 居中模型
         */
        function centerModel(model) {
            // 计算包围盒
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // 计算模型尺寸和中心点
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = window.camera.fov * (Math.PI / 180);
            
            // 计算更合适的相机距离，确保整个模型都在视野内
            let cameraZ = Math.abs(maxDim / Math.sin(fov / 2)) * 2.0;
            
            // 显示模型信息
            console.log(`模型尺寸: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`);
            console.log(`最大尺寸: ${maxDim.toFixed(2)}, 相机距离: ${cameraZ.toFixed(2)}`);

            // 调整相机位置，增加高度和距离
            window.camera.position.set(
                center.x + size.x * 0.5, 
                center.y + size.y * 0.5, 
                center.z + cameraZ
            );
            window.camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
        }

        /**
         * 重置相机
         */
        function resetCamera() {
            if (currentModel) {
                centerModel(currentModel);
            } else {
                window.camera.position.set(0, 5, 10);
                window.camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        /**
         * 窗口大小变化处理
         */
        function onWindowResize() {
            window.camera.aspect = window.innerWidth / window.innerHeight;
            window.camera.updateProjectionMatrix();
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * 动画循环
         */
        function animate() {
            requestAnimationFrame(animate);

            // 更新控制器
            controls.update();

            // 更新动画混合器
            if (mixer) {
                const delta = clock.getDelta();
                mixer.update(delta);
            }

            // 渲染场景
            window.renderer.render(window.scene, window.camera);
        }
    </script>
    
    <!-- 截图功能脚本 - 请勿修改此部分 -->
    <script>
        // 全局变量，用于存储渲染器引用
        let _screenshotRenderer;
        
        // 添加消息监听器，处理截图请求
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'take-screenshot') {
                try {
                    // 获取当前渲染器
                    if (!_screenshotRenderer && window.renderer) {
                        _screenshotRenderer = window.renderer;
                    }
                    
                    // 确保渲染器已经初始化
                    if (!_screenshotRenderer) {
                        throw new Error('渲染器未初始化');
                    }
                    
                    // 强制渲染一帧，确保内容是最新的
                    if (window.scene && window.camera) {
                        _screenshotRenderer.render(window.scene, window.camera);
                    }
                    
                    // 获取canvas的图像数据（使用较低的质量和尺寸以减小文件大小）
                    const quality = event.data.quality || 0.8;
                    const canvas = _screenshotRenderer.domElement;
                    
                    // 创建一个较小尺寸的临时canvas
                    const tempCanvas = document.createElement('canvas');
                    const maxSize = 600; // 最大尺寸为600像素
                    
                    // 计算缩放比例，保持宽高比
                    const scale = Math.min(maxSize / canvas.width, maxSize / canvas.height);
                    tempCanvas.width = Math.floor(canvas.width * scale);
                    tempCanvas.height = Math.floor(canvas.height * scale);
                    
                    // 在临时canvas上绘制缩小的图像
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // 获取缩小后的图像数据
                    const dataUrl = tempCanvas.toDataURL('image/jpeg', quality);
                    
                    // 将图像数据发送回父窗口
                    window.parent.postMessage({
                        type: 'screenshot-data',
                        dataUrl: dataUrl
                    }, '*');
                } catch (error) {
                    console.error('截图失败:', error);
                    // 发送错误信息回父窗口
                    window.parent.postMessage({
                        type: 'screenshot-error',
                        error: error.message
                    }, '*');
                }
            }
        });
    </script>
</body>
</html>