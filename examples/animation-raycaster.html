<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 页面描述，有助于SEO优化 -->
    <meta name="description" content="使用射线检测实现对象选择和交互">
    <!-- Three.js版本信息 -->
    <meta name="three-version" content="r179">
    <title>Three.js 示例 - 射线检测</title>
    <!-- 引入公共样式表 -->
    <link rel="stylesheet" href="../css/example-common.css">
    <style>
        #infoPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
            max-width: 250px;
            font-size: 14px;
            line-height: 1.4;
        }
        
        /* 在大屏幕上避免与GUI面板重叠 */
        @media (min-width: 1200px) {
            #infoPanel {
                right: 320px;
                left: auto;
            }
        }
    </style>
</head>
<body>
    <!-- 3D场景容器 -->
    <div class="three-container" id="threeContainer"></div>
    
    <!-- 射线检测信息面板 -->
    <div id="infoPanel">
        <div><strong>射线检测</strong></div>
        <div>鼠标悬停: <span id="hoverInfo">无</span></div>
        <div>选中对象: <span id="selectedInfo">无</span></div>
        <div>射线距离: <span id="distanceInfo">-</span></div>
        <div style="margin-top: 8px; font-size: 12px; color: #ccc;">
            点击选择对象<br>
            悬停查看信息
        </div>
    </div>
    
    <!-- 
    使用importmap定义模块导入映射
    这是一种现代化的ES模块导入方式，可以简化导入路径
    通过定义别名，可以使用简短的导入语句，如 import * as THREE from 'three'
    -->
    <script type="importmap">
        {
            "imports": {
                "three": "../libs/three/r179/build/three.module.js",
                "three/addons/": "../libs/three/r179/jsm/"
            }
        }
    </script>
    
    <!-- 示例代码 - 射线检测 -->
    <script type="module">
        // 导入Three.js核心模块
        import * as THREE from 'three';
        // 导入轨道控制器，用于交互式旋转和缩放场景
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // 导入GUI控制面板，用于调整参数
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        
        // Three.js 核心变量 - 暴露给全局作用域以便截图功能使用
        window.scene = null;     // 场景对象，包含所有3D元素
        window.camera = null;    // 相机对象，定义视角和视野
        window.renderer = null;  // 渲染器对象，将场景渲染到canvas上
        let controls;           // 轨道控制器对象
        let objects = [];       // 3D对象数组
        let raycaster, mouse;   // 射线检测器和鼠标位置
        let hoveredObject = null;   // 当前悬停的对象
        let selectedObject = null;  // 当前选中的对象
        let rayHelper = null;       // 射线辅助线
        
        // 参数配置对象 - 用于GUI控制面板和创建3D对象
        const params = {
            // 对象设置参数
            objectCount: 15,        // 对象数量
            objectSize: 0.5,        // 对象大小
            animationSpeed: 1.0,    // 动画速度
            
            // 射线检测设置参数
            showRayHelper: false,   // 是否显示射线辅助线
            rayLength: 50,          // 射线长度
            rayColor: 0xff0000,     // 射线颜色（红色）
            
            // 交互效果设置参数
            hoverColor: 0xff6b6b,   // 悬停颜色（浅红色）
            selectedColor: 0x4ecdc4, // 选中颜色（青色）
            normalColor: 0x3498db,  // 正常颜色（蓝色）
            
            // 控制功能
            resetSelection: function() {
                if (selectedObject) {
                    selectedObject.material.color.setHex(params.normalColor);
                    selectedObject = null;
                    document.getElementById('selectedInfo').textContent = '无';
                }
            }
        };
        
        /**
         * 初始化Three.js场景、相机、渲染器和控制器
         * 这是整个应用的入口点
         */
        function init() {
            // 创建场景 - 所有3D对象的容器
            window.scene = new THREE.Scene();
            // 设置场景背景色为深蓝灰色
            window.scene.background = new THREE.Color(0x2c3e50);
            
            // 创建透视相机 - 模拟人眼视角
            // 参数：视场角(FOV)，宽高比，近裁剪面，远裁剪面
            window.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // 设置相机位置，以便能看到场景中的对象
            window.camera.position.set(0, 5, 10);
            
            // 创建WebGL渲染器 - 将3D场景渲染到canvas上
            window.renderer = new THREE.WebGLRenderer({ antialias: true }); // 启用抗锯齿
            // 设置渲染器尺寸为窗口大小
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            // 设置设备像素比，提高在高DPI设备上的清晰度
            window.renderer.setPixelRatio(window.devicePixelRatio);
            // 启用阴影映射
            window.renderer.shadowMap.enabled = true;
            window.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            // 将渲染器的canvas添加到DOM中
            document.getElementById('threeContainer').appendChild(window.renderer.domElement);
            
            // 添加轨道控制器 - 允许用户交互式旋转和缩放场景
            controls = new OrbitControls(window.camera, window.renderer.domElement);
            controls.enableDamping = true;       // 启用阻尼效果，使控制更平滑
            controls.dampingFactor = 0.05;       // 阻尼系数
            
            // 创建射线检测器和鼠标位置向量
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // 添加环境光 - 提供均匀的全局照明
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            window.scene.add(ambientLight);
            
            // 添加方向光 - 模拟太阳光
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5); // 设置光源位置
            directionalLight.castShadow = true;       // 启用阴影投射
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            window.scene.add(directionalLight);
            
            // 创建地面
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x34495e });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            window.scene.add(ground);
            
            // 创建网格辅助线
            const gridHelper = new THREE.GridHelper(20, 20, 0x7f8c8d, 0x7f8c8d);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            window.scene.add(gridHelper);
            
            // 创建射线辅助线
            rayHelper = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, -1),
                new THREE.Vector3(0, 0, 0),
                params.rayLength,
                params.rayColor
            );
            rayHelper.visible = params.showRayHelper;
            window.scene.add(rayHelper);
            
            // 创建3D对象
            createObjects();
            
            // 初始化GUI控制面板
            initGUI();
            
            // 监听窗口大小变化，调整场景
            window.addEventListener('resize', onWindowResize);
            // 监听鼠标移动事件，用于射线检测
            window.renderer.domElement.addEventListener('mousemove', onMouseMove);
            // 监听鼠标点击事件，用于对象选择
            window.renderer.domElement.addEventListener('click', onMouseClick);
            
            // 开始动画循环
            animate();
        }
        
        /**
         * 处理窗口大小变化
         * 调整相机和渲染器以适应新的窗口尺寸
         */
        function onWindowResize() {
            // 更新相机宽高比
            window.camera.aspect = window.innerWidth / window.innerHeight;
            // 更新相机投影矩阵
            window.camera.updateProjectionMatrix();
            // 更新渲染器尺寸
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        /**
         * 创建3D对象
         * 根据当前参数创建多个不同类型的几何体对象
         */
        function createObjects() {
            // 清除现有对象
            objects.forEach(obj => window.scene.remove(obj));
            objects = [];

            // 创建不同类型的几何体
            const geometries = [
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.SphereGeometry(0.6, 16, 12),
                new THREE.CylinderGeometry(0.5, 0.5, 1, 12),
                new THREE.ConeGeometry(0.6, 1.2, 8),
                new THREE.TorusGeometry(0.6, 0.2, 8, 16)
            ];

            for (let i = 0; i < params.objectCount; i++) {
                const geometry = geometries[i % geometries.length];
                const material = new THREE.MeshPhongMaterial({ 
                    color: params.normalColor,
                    shininess: 100
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // 随机位置
                mesh.position.x = (Math.random() - 0.5) * 16;
                mesh.position.y = Math.random() * 3 + 0.5;
                mesh.position.z = (Math.random() - 0.5) * 16;
                
                // 随机旋转
                mesh.rotation.x = Math.random() * Math.PI;
                mesh.rotation.y = Math.random() * Math.PI;
                mesh.rotation.z = Math.random() * Math.PI;
                
                // 随机缩放
                const scale = params.objectSize * (0.5 + Math.random() * 0.5);
                mesh.scale.setScalar(scale);
                
                // 启用阴影
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // 添加用户数据
                mesh.userData = {
                    id: i,
                    type: ['Box', 'Sphere', 'Cylinder', 'Cone', 'Torus'][i % 5],
                    originalColor: params.normalColor
                };
                
                window.scene.add(mesh);
                objects.push(mesh);
            }
        }
        
        /**
         * 初始化GUI控制面板
         * 创建用户可交互的控制界面，用于调整参数
         */
        function initGUI() {
            // 创建GUI实例
            const gui = new GUI({ title: '射线检测控制面板', width: 300 });
            
            // 调整GUI位置，避免与其他UI元素重叠
            gui.domElement.style.position = 'absolute';
            gui.domElement.style.top = '60px';
            gui.domElement.style.right = '10px';
            
            // 确保GUI在所有环境下都可见
            gui.domElement.style.zIndex = '1000';
            gui.domElement.style.maxHeight = '80vh'; // 限制最大高度
            gui.domElement.style.overflowY = 'auto'; // 允许垂直滚动
            
            // 确保GUI在页面加载后立即可见
            setTimeout(() => {
                gui.show();
                // 强制更新GUI
                for (const controller of gui.controllers) {
                    controller.updateDisplay();
                }
            }, 100);
            
            // 对象设置控制组
            const objectFolder = gui.addFolder('对象设置');
            objectFolder.add(params, 'objectCount', 5, 30, 1)
                .onChange(createObjects)
                .name('对象数量');
            objectFolder.add(params, 'objectSize', 0.2, 2.0, 0.1)
                .onChange(updateObjectSizes)
                .name('对象大小');
            objectFolder.add(params, 'animationSpeed', 0, 3, 0.1)
                .name('动画速度');
            objectFolder.open();

            // 射线检测设置控制组
            const rayFolder = gui.addFolder('射线检测设置');
            rayFolder.add(params, 'showRayHelper')
                .onChange(value => {
                    rayHelper.visible = value;
                })
                .name('显示射线辅助线');
            rayFolder.add(params, 'rayLength', 10, 100, 5)
                .onChange(value => {
                    rayHelper.setLength(value);
                })
                .name('射线长度');
            rayFolder.addColor(params, 'rayColor')
                .onChange(value => {
                    rayHelper.setColor(value);
                })
                .name('射线颜色');

            // 交互效果设置控制组
            const effectFolder = gui.addFolder('交互效果设置');
            effectFolder.addColor(params, 'hoverColor')
                .name('悬停颜色');
            effectFolder.addColor(params, 'selectedColor')
                .name('选中颜色');
            effectFolder.addColor(params, 'normalColor')
                .onChange(value => {
                    objects.forEach(obj => {
                        if (obj !== hoveredObject && obj !== selectedObject) {
                            obj.material.color.setHex(value);
                            obj.userData.originalColor = value;
                        }
                    });
                })
                .name('正常颜色');
            effectFolder.open();

            // 控制功能
            const controlFolder = gui.addFolder('控制功能');
            controlFolder.add(params, 'resetSelection')
                .name('重置选择');
        }
        
        /**
         * 更新对象大小
         * 根据参数重新设置所有对象的缩放
         */
        function updateObjectSizes() {
            objects.forEach(obj => {
                const scale = params.objectSize * (0.5 + Math.random() * 0.5);
                obj.scale.setScalar(scale);
            });
        }
        
        /**
         * 处理鼠标移动事件
         * 更新射线检测和对象悬停效果
         */
        function onMouseMove(event) {
            // 计算鼠标位置（标准化设备坐标）
            const rect = window.renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // 更新射线
            raycaster.setFromCamera(mouse, window.camera);
            
            // 更新射线辅助线
            if (params.showRayHelper) {
                const origin = raycaster.ray.origin.clone();
                const direction = raycaster.ray.direction.clone();
                rayHelper.position.copy(origin);
                rayHelper.setDirection(direction);
            }

            // 检测相交对象
            const intersects = raycaster.intersectObjects(objects);

            // 重置之前悬停的对象
            if (hoveredObject && hoveredObject !== selectedObject) {
                hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
            }

            if (intersects.length > 0) {
                const intersect = intersects[0];
                hoveredObject = intersect.object;
                
                // 设置悬停颜色
                if (hoveredObject !== selectedObject) {
                    hoveredObject.material.color.setHex(params.hoverColor);
                }
                
                // 更新信息显示
                document.getElementById('hoverInfo').textContent = 
                    `${hoveredObject.userData.type} #${hoveredObject.userData.id}`;
                document.getElementById('distanceInfo').textContent = 
                    `${intersect.distance.toFixed(2)}`;
            } else {
                hoveredObject = null;
                document.getElementById('hoverInfo').textContent = '无';
                document.getElementById('distanceInfo').textContent = '-';
            }
        }
        
        /**
         * 处理鼠标点击事件
         * 选择或取消选择对象
         */
        function onMouseClick(event) {
            if (hoveredObject) {
                // 重置之前选中的对象
                if (selectedObject) {
                    selectedObject.material.color.setHex(selectedObject.userData.originalColor);
                }
                
                // 设置新的选中对象
                selectedObject = hoveredObject;
                selectedObject.material.color.setHex(params.selectedColor);
                
                // 更新信息显示
                document.getElementById('selectedInfo').textContent = 
                    `${selectedObject.userData.type} #${selectedObject.userData.id}`;
            }
        }
        
        /**
         * 动画循环函数
         * 使用requestAnimationFrame实现平滑动画
         * 每帧更新场景并渲染
         */
        function animate() {
            // 请求下一帧动画
            requestAnimationFrame(animate);

            // 更新轨道控制器
            // 如果启用了阻尼效果，需要在每帧调用update
            controls.update();

            // 旋转对象动画
            const time = Date.now() * 0.001 * params.animationSpeed;
            objects.forEach((obj, index) => {
                obj.rotation.x += 0.005 * params.animationSpeed;
                obj.rotation.y += 0.01 * params.animationSpeed;
                
                // 添加轻微的上下浮动
                obj.position.y += Math.sin(time + index) * 0.002 * params.animationSpeed;
            });

            // 渲染场景
            window.renderer.render(window.scene, window.camera);
        }
        
        // 初始化应用
        init();
    </script>
    
    <!-- 
    ===================================================
    截图功能脚本 - 请勿修改此部分
    此脚本处理从父窗口发来的截图请求，用于生成示例封面，与示例业务并无关联
    ===================================================
    -->
    <script>
        // 全局变量，用于存储渲染器引用
        let _screenshotRenderer;
        
        // 添加消息监听器，处理截图请求
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'take-screenshot') {
                try {
                    // 获取当前渲染器
                    if (!_screenshotRenderer && window.renderer) {
                        _screenshotRenderer = window.renderer;
                    }
                    
                    // 确保渲染器已经初始化
                    if (!_screenshotRenderer) {
                        throw new Error('渲染器未初始化');
                    }
                    
                    // 强制渲染一帧，确保内容是最新的
                    if (window.scene && window.camera) {
                        _screenshotRenderer.render(window.scene, window.camera);
                    }
                    
                    // 获取canvas的图像数据（使用较低的质量和尺寸以减小文件大小）
                    const quality = event.data.quality || 0.8;
                    const canvas = _screenshotRenderer.domElement;
                    
                    // 创建一个较小尺寸的临时canvas
                    const tempCanvas = document.createElement('canvas');
                    const maxSize = 600; // 最大尺寸为600像素
                    
                    // 计算缩放比例，保持宽高比
                    const scale = Math.min(maxSize / canvas.width, maxSize / canvas.height);
                    tempCanvas.width = Math.floor(canvas.width * scale);
                    tempCanvas.height = Math.floor(canvas.height * scale);
                    
                    // 在临时canvas上绘制缩小的图像
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // 获取缩小后的图像数据
                    const dataUrl = tempCanvas.toDataURL('image/jpeg', quality);
                    
                    // 将图像数据发送回父窗口
                    window.parent.postMessage({
                        type: 'screenshot-data',
                        dataUrl: dataUrl
                    }, '*');
                } catch (error) {
                    console.error('截图失败:', error);
                    // 发送错误信息回父窗口
                    window.parent.postMessage({
                        type: 'screenshot-error',
                        error: error.message
                    }, '*');
                }
            }
        });
    </script>
</body>
</html>