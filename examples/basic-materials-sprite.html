<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 页面描述，有助于SEO优化 -->
    <meta name="description" content="Three.js精灵材质示例 - 展示SpriteMaterial的使用方法和效果">
    <!-- Three.js版本信息 -->
    <meta name="three-version" content="r179">
    <title>Three.js 示例 - 精灵材质</title>
    <!-- 引入公共样式表 -->
    <link rel="stylesheet" href="../css/example-common.css">
</head>
<body>
    <!-- 3D场景容器 -->
    <div class="three-container" id="threeContainer"></div>
    
    <!-- 
    使用importmap定义模块导入映射
    这是一种现代化的ES模块导入方式，可以简化导入路径
    通过定义别名，可以使用简短的导入语句，如 import * as THREE from 'three'
    -->
    <script type="importmap">
        {
            "imports": {
                "three": "../libs/three/r179/build/three.module.js",
                "three/addons/": "../libs/three/r179/jsm/"
            }
        }
    </script>
    
    <!-- 示例代码 - 精灵材质 -->
    <script type="module">
        // 导入Three.js核心模块
        import * as THREE from 'three';
        // 导入轨道控制器，用于交互式旋转和缩放场景
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // 导入GUI控制面板，用于调整参数
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        
        // Three.js 核心变量 - 暴露给全局作用域以便截图功能使用
        window.scene = null;     // 场景对象，包含所有3D元素
        window.camera = null;    // 相机对象，定义视角和视野
        window.renderer = null;  // 渲染器对象，将场景渲染到canvas上
        let sprites = [];        // 精灵对象数组
        let controls;            // 轨道控制器对象
        let clock = new THREE.Clock(); // 时钟对象，用于动画
        
        // 参数配置对象 - 用于GUI控制面板和创建3D对象
        const params = {
            // 精灵参数
            count: 100,           // 精灵数量
            size: 1,              // 精灵大小
            distribution: 'sphere', // 分布方式：sphere, cube, plane
            distributionRadius: 10, // 分布半径
            
            // 材质参数
            color: '#ffffff',     // 颜色
            opacity: 1.0,         // 不透明度
            transparent: true,    // 是否透明
            sizeAttenuation: true, // 是否根据距离衰减大小
            useTexture: true,     // 是否使用纹理
            textureType: 'circle', // 纹理类型：circle, star, glow, custom
            
            // 动画参数
            animate: true,        // 是否启用动画
            animationSpeed: 1.0,  // 动画速度
            rotationSpeed: 0.5,   // 旋转速度
            
            // 控制器参数
            autoRotate: true      // 是否自动旋转
        };
        
        // 纹理加载器
        const textureLoader = new THREE.TextureLoader();
        let spriteTextures = {};
        
        /**
         * 初始化Three.js场景、相机、渲染器和控制器
         * 这是整个应用的入口点
         */
        function init() {
            // 创建场景 - 所有3D对象的容器
            window.scene = new THREE.Scene();
            // 设置场景背景色为深蓝灰色
            window.scene.background = new THREE.Color(0x2c3e50);
            
            // 创建透视相机 - 模拟人眼视角
            // 参数：视场角(FOV)，宽高比，近裁剪面，远裁剪面
            window.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // 设置相机位置，以便能看到场景中的对象
            window.camera.position.set(0, 0, 20);
            
            // 创建WebGL渲染器 - 将3D场景渲染到canvas上
            window.renderer = new THREE.WebGLRenderer({ antialias: true }); // 启用抗锯齿
            // 设置渲染器尺寸为窗口大小
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            // 设置设备像素比，提高在高DPI设备上的清晰度
            window.renderer.setPixelRatio(window.devicePixelRatio);
            // 将渲染器的canvas添加到DOM中
            document.getElementById('threeContainer').appendChild(window.renderer.domElement);
            
            // 添加轨道控制器 - 允许用户交互式旋转和缩放场景
            controls = new OrbitControls(window.camera, window.renderer.domElement);
            controls.enableDamping = true;       // 启用阻尼效果，使控制更平滑
            controls.dampingFactor = 0.05;       // 阻尼系数
            controls.autoRotate = params.autoRotate; // 设置是否自动旋转
            controls.autoRotateSpeed = 0.5;      // 自动旋转速度
            
            // 添加环境光 - 提供均匀的全局照明
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            window.scene.add(ambientLight);
            
            // 添加方向光 - 模拟太阳光
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1); // 设置光源位置
            window.scene.add(directionalLight);
            
            // 预加载纹理
            loadTextures();
            
            // 创建精灵
            createSprites();
            
            // 初始化GUI控制面板
            initGUI();
            
            // 监听窗口大小变化，调整场景
            window.addEventListener('resize', onWindowResize);
            
            // 开始动画循环
            animate();
        }
        
        /**
         * 加载精灵纹理
         */
        function loadTextures() {
            // 创建圆形纹理
            const circleCanvas = document.createElement('canvas');
            circleCanvas.width = 128;
            circleCanvas.height = 128;
            const circleContext = circleCanvas.getContext('2d');
            
            // 绘制圆形
            circleContext.beginPath();
            circleContext.arc(64, 64, 60, 0, Math.PI * 2);
            circleContext.closePath();
            circleContext.fillStyle = 'white';
            circleContext.fill();
            
            // 创建圆形纹理
            spriteTextures.circle = new THREE.CanvasTexture(circleCanvas);
            
            // 创建星形纹理
            const starCanvas = document.createElement('canvas');
            starCanvas.width = 128;
            starCanvas.height = 128;
            const starContext = starCanvas.getContext('2d');
            
            // 绘制五角星
            starContext.beginPath();
            const points = 5;
            const outerRadius = 60;
            const innerRadius = 30;
            const cx = 64;
            const cy = 64;
            
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / points;
                const x = cx + radius * Math.sin(angle);
                const y = cy + radius * Math.cos(angle);
                
                if (i === 0) {
                    starContext.moveTo(x, y);
                } else {
                    starContext.lineTo(x, y);
                }
            }
            
            starContext.closePath();
            starContext.fillStyle = 'white';
            starContext.fill();
            
            // 创建星形纹理
            spriteTextures.star = new THREE.CanvasTexture(starCanvas);
            
            // 创建发光纹理
            const glowCanvas = document.createElement('canvas');
            glowCanvas.width = 128;
            glowCanvas.height = 128;
            const glowContext = glowCanvas.getContext('2d');
            
            // 创建径向渐变
            const gradient = glowContext.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            // 绘制发光圆
            glowContext.fillStyle = gradient;
            glowContext.fillRect(0, 0, 128, 128);
            
            // 创建发光纹理
            spriteTextures.glow = new THREE.CanvasTexture(glowCanvas);
            
            // 加载自定义纹理
            spriteTextures.custom = textureLoader.load('../images/textures/sprite-particle.png', function(texture) {
                // 纹理加载完成后，如果当前选择的是自定义纹理，则更新精灵
                if (params.textureType === 'custom') {
                    updateSpriteMaterial();
                }
            });
        }
        
        /**
         * 创建精灵对象
         */
        function createSprites() {
            // 清除现有的精灵
            sprites.forEach(sprite => window.scene.remove(sprite));
            sprites = [];
            
            // 获取当前选择的纹理
            const texture = spriteTextures[params.textureType] || spriteTextures.circle;
            
            // 创建精灵材质
            const material = new THREE.SpriteMaterial({
                map: params.useTexture ? texture : null,
                color: params.color,
                transparent: params.transparent,
                opacity: params.opacity,
                sizeAttenuation: params.sizeAttenuation
            });
            
            // 根据分布方式创建精灵
            for (let i = 0; i < params.count; i++) {
                // 创建精灵
                const sprite = new THREE.Sprite(material.clone());
                
                // 设置位置
                const position = getDistributionPosition(i);
                sprite.position.copy(position);
                
                // 设置大小
                const size = params.size * (0.5 + Math.random() * 0.5);
                sprite.scale.set(size, size, 1);
                
                // 添加到场景
                window.scene.add(sprite);
                sprites.push(sprite);
            }
        }
        
        /**
         * 根据分布方式获取位置
         * @param {number} index - 精灵索引
         * @returns {THREE.Vector3} - 位置向量
         */
        function getDistributionPosition(index) {
            const position = new THREE.Vector3();
            const radius = params.distributionRadius;
            
            switch (params.distribution) {
                case 'sphere':
                    // 球面分布
                    const phi = Math.acos(-1 + (2 * index) / params.count);
                    const theta = Math.sqrt(params.count * Math.PI) * phi;
                    
                    position.x = radius * Math.cos(theta) * Math.sin(phi);
                    position.y = radius * Math.sin(theta) * Math.sin(phi);
                    position.z = radius * Math.cos(phi);
                    break;
                    
                case 'cube':
                    // 立方体分布
                    position.x = (Math.random() - 0.5) * 2 * radius;
                    position.y = (Math.random() - 0.5) * 2 * radius;
                    position.z = (Math.random() - 0.5) * 2 * radius;
                    break;
                    
                case 'plane':
                    // 平面分布
                    position.x = (Math.random() - 0.5) * 2 * radius;
                    position.y = (Math.random() - 0.5) * 2 * radius;
                    position.z = 0;
                    break;
                    
                default:
                    // 默认随机分布
                    const u = Math.random();
                    const v = Math.random();
                    
                    const theta2 = 2 * Math.PI * u;
                    const phi2 = Math.acos(2 * v - 1);
                    
                    position.x = radius * Math.sin(phi2) * Math.cos(theta2);
                    position.y = radius * Math.sin(phi2) * Math.sin(theta2);
                    position.z = radius * Math.cos(phi2);
            }
            
            return position;
        }
        
        /**
         * 更新精灵材质
         */
        function updateSpriteMaterial() {
            // 获取当前选择的纹理
            const texture = spriteTextures[params.textureType] || spriteTextures.circle;
            
            // 更新所有精灵的材质
            sprites.forEach(sprite => {
                sprite.material.map = params.useTexture ? texture : null;
                sprite.material.color.set(params.color);
                sprite.material.transparent = params.transparent;
                sprite.material.opacity = params.opacity;
                sprite.material.sizeAttenuation = params.sizeAttenuation;
                sprite.material.needsUpdate = true;
            });
        }
        
        /**
         * 初始化GUI控制面板
         */
        function initGUI() {
            // 创建GUI实例
            const gui = new GUI({ title: '精灵材质控制面板', width: 300 });
            
            // 调整GUI位置，避免与其他UI元素重叠
            gui.domElement.style.position = 'absolute';
            gui.domElement.style.top = '60px';
            gui.domElement.style.right = '10px';
            
            // 确保GUI在所有环境下都可见
            gui.domElement.style.zIndex = '1000';
            gui.domElement.style.maxHeight = '80vh'; // 限制最大高度
            gui.domElement.style.overflowY = 'auto'; // 允许垂直滚动
            
            // 确保GUI在页面加载后立即可见
            setTimeout(() => {
                gui.show();
                // 强制更新GUI
                for (const controller of gui.controllers) {
                    controller.updateDisplay();
                }
            }, 100);
            
            // 精灵分布参数
            const distributionFolder = gui.addFolder('精灵分布');
            
            distributionFolder.add(params, 'count', 10, 1000)
                .step(10)
                .name('数量')
                .onChange(createSprites);
                
            distributionFolder.add(params, 'size', 0.1, 5)
                .step(0.1)
                .name('大小')
                .onChange(() => {
                    sprites.forEach(sprite => {
                        const size = params.size * (0.5 + Math.random() * 0.5);
                        sprite.scale.set(size, size, 1);
                    });
                });
                
            distributionFolder.add(params, 'distribution', {
                '球面分布': 'sphere',
                '立方体分布': 'cube',
                '平面分布': 'plane'
            })
                .name('分布方式')
                .onChange(createSprites);
                
            distributionFolder.add(params, 'distributionRadius', 1, 20)
                .step(1)
                .name('分布半径')
                .onChange(createSprites);
                
            // 默认展开此文件夹
            distributionFolder.open();
            
            // 材质参数
            const materialFolder = gui.addFolder('材质参数');
            
            materialFolder.addColor(params, 'color')
                .name('颜色')
                .onChange(updateSpriteMaterial);
                
            materialFolder.add(params, 'opacity', 0, 1)
                .step(0.01)
                .name('不透明度')
                .onChange(updateSpriteMaterial);
                
            materialFolder.add(params, 'transparent')
                .name('启用透明')
                .onChange(updateSpriteMaterial);
                
            materialFolder.add(params, 'sizeAttenuation')
                .name('大小衰减')
                .onChange(updateSpriteMaterial);
                
            materialFolder.add(params, 'useTexture')
                .name('使用纹理')
                .onChange(updateSpriteMaterial);
                
            materialFolder.add(params, 'textureType', {
                '圆形': 'circle',
                '星形': 'star',
                '发光': 'glow',
                '自定义': 'custom'
            })
                .name('纹理类型')
                .onChange(updateSpriteMaterial);
                
            // 默认展开此文件夹
            materialFolder.open();
            
            // 动画参数
            const animationFolder = gui.addFolder('动画参数');
            
            animationFolder.add(params, 'animate')
                .name('启用动画');
                
            animationFolder.add(params, 'animationSpeed', 0.1, 5)
                .step(0.1)
                .name('动画速度');
                
            animationFolder.add(params, 'rotationSpeed', 0, 2)
                .step(0.1)
                .name('旋转速度');
                
            animationFolder.add(params, 'autoRotate')
                .name('自动旋转')
                .onChange(value => {
                    controls.autoRotate = value;
                });
                
            // 默认展开此文件夹
            animationFolder.open();
        }
        
        /**
         * 处理窗口大小变化
         * 调整相机和渲染器以适应新的窗口尺寸
         */
        function onWindowResize() {
            // 更新相机宽高比
            window.camera.aspect = window.innerWidth / window.innerHeight;
            // 更新相机投影矩阵
            window.camera.updateProjectionMatrix();
            // 更新渲染器尺寸
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        /**
         * 动画循环函数
         * 使用requestAnimationFrame实现平滑动画
         * 每帧更新场景并渲染
         */
        function animate() {
            // 请求下一帧动画
            requestAnimationFrame(animate);
            
            // 更新轨道控制器
            // 如果启用了阻尼效果，需要在每帧调用update
            controls.update();
            
            // 动画效果
            if (params.animate) {
                const time = clock.getElapsedTime() * params.animationSpeed;
                
                // 更新精灵动画
                sprites.forEach((sprite, i) => {
                    // 旋转精灵
                    sprite.material.rotation += 0.01 * params.rotationSpeed;
                    
                    // 根据分布方式应用不同的动画效果
                    if (params.distribution === 'sphere') {
                        // 球面脉动效果
                        const pulseScale = 1 + 0.1 * Math.sin(time + i * 0.1);
                        const baseSize = params.size * (0.5 + Math.random() * 0.5);
                        sprite.scale.set(baseSize * pulseScale, baseSize * pulseScale, 1);
                    } else if (params.distribution === 'cube') {
                        // 立方体内随机移动
                        sprite.position.x += Math.sin(time + i) * 0.01;
                        sprite.position.y += Math.cos(time + i * 0.5) * 0.01;
                        sprite.position.z += Math.sin(time * 0.5 + i * 0.2) * 0.01;
                        
                        // 保持在分布范围内
                        const radius = params.distributionRadius;
                        if (Math.abs(sprite.position.x) > radius) sprite.position.x *= -0.9;
                        if (Math.abs(sprite.position.y) > radius) sprite.position.y *= -0.9;
                        if (Math.abs(sprite.position.z) > radius) sprite.position.z *= -0.9;
                    } else if (params.distribution === 'plane') {
                        // 平面波浪效果
                        sprite.position.z = Math.sin(time + sprite.position.x * 0.2) * 2;
                    }
                });
            }
            
            // 渲染场景
            window.renderer.render(window.scene, window.camera);
        }
        
        // 初始化应用
        init();
    </script>
    
    <!-- 
    ===================================================
    截图功能脚本 - 请勿修改此部分
    此脚本处理从父窗口发来的截图请求，用于生成示例封面，与示例业务并无关联
    ===================================================
    -->
    <script>
        // 全局变量，用于存储渲染器引用
        let _screenshotRenderer;
        
        // 添加消息监听器，处理截图请求
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'take-screenshot') {
                try {
                    // 获取当前渲染器
                    if (!_screenshotRenderer && window.renderer) {
                        _screenshotRenderer = window.renderer;
                    }
                    
                    // 确保渲染器已经初始化
                    if (!_screenshotRenderer) {
                        throw new Error('渲染器未初始化');
                    }
                    
                    // 强制渲染一帧，确保内容是最新的
                    if (window.scene && window.camera) {
                        _screenshotRenderer.render(window.scene, window.camera);
                    }
                    
                    // 获取canvas的图像数据（使用较低的质量和尺寸以减小文件大小）
                    const quality = event.data.quality || 0.8;
                    const canvas = _screenshotRenderer.domElement;
                    
                    // 创建一个较小尺寸的临时canvas
                    const tempCanvas = document.createElement('canvas');
                    const maxSize = 600; // 最大尺寸为600像素
                    
                    // 计算缩放比例，保持宽高比
                    const scale = Math.min(maxSize / canvas.width, maxSize / canvas.height);
                    tempCanvas.width = Math.floor(canvas.width * scale);
                    tempCanvas.height = Math.floor(canvas.height * scale);
                    
                    // 在临时canvas上绘制缩小的图像
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // 获取缩小后的图像数据
                    const dataUrl = tempCanvas.toDataURL('image/jpeg', quality);
                    
                    // 将图像数据发送回父窗口
                    window.parent.postMessage({
                        type: 'screenshot-data',
                        dataUrl: dataUrl
                    }, '*');
                } catch (error) {
                    console.error('截图失败:', error);
                    // 发送错误信息回父窗口
                    window.parent.postMessage({
                        type: 'screenshot-error',
                        error: error.message
                    }, '*');
                }
            }
        });
    </script>
</body>
</html>