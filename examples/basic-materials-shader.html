<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 页面描述，有助于SEO优化 -->
    <meta name="description" content="使用ShaderMaterial创建自定义着色器效果，展示Three.js内置变量和着色器编程技术。">
    <!-- Three.js版本信息 -->
    <meta name="three-version" content="r179">
    <title>Three.js 示例 - 着色器材质</title>
    <!-- 引入公共样式表 -->
    <link rel="stylesheet" href="../css/example-common.css">
</head>
<body>
    <!-- 3D场景容器 -->
    <div class="three-container" id="threeContainer"></div>
    
    <!-- 
    使用importmap定义模块导入映射
    这是一种现代化的ES模块导入方式，可以简化导入路径
    通过定义别名，可以使用简短的导入语句，如 import * as THREE from 'three'
    -->
    <script type="importmap">
        {
            "imports": {
                "three": "../libs/three/r179/build/three.module.js",
                "three/addons/": "../libs/three/r179/jsm/"
            }
        }
    </script>
    
    <!-- 示例代码 - 着色器材质 -->
    <script type="module">
        // 导入Three.js核心模块
        import * as THREE from 'three';
        // 导入轨道控制器，用于交互式旋转和缩放场景
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // 导入GUI控制面板，用于调整参数
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        
        // Three.js 核心变量 - 暴露给全局作用域以便截图功能使用
        window.scene = null;     // 场景对象，包含所有3D元素
        window.camera = null;    // 相机对象，定义视角和视野
        window.renderer = null;  // 渲染器对象，将场景渲染到canvas上
        let mesh;               // 3D网格对象
        let controls;           // 轨道控制器对象
        let clock;              // 时钟对象，用于动画
        
        // 参数配置对象 - 用于GUI控制面板和创建3D对象
        const params = {
            // 几何体参数
            geometry: 'sphere',   // 几何体类型
            radius: 1.0,          // 半径
            segments: 32,         // 分段数
            
            // 着色器参数
            shaderType: 'wave',   // 着色器类型
            amplitude: 0.1,       // 波浪振幅
            frequency: 2.0,       // 波浪频率
            speed: 1.0,           // 动画速度
            colorA: '#4285f4',    // 颜色A（蓝色）
            colorB: '#34a853',    // 颜色B（绿色）
            wireframe: false,     // 是否显示线框模式
            
            // 控制器参数
            autoRotate: true      // 是否自动旋转
        };
        
        // 波浪效果顶点着色器
        const waveVertexShader = `
            // ShaderMaterial自动包含Three.js的内置变量和属性
            // 不需要像RawShaderMaterial那样明确定义
            
            uniform float time;
            uniform float amplitude;
            uniform float frequency;
            
            varying vec2 vUv;
            varying float vElevation;
            
            void main() {
                // 传递UV坐标给片元着色器
                vUv = uv;
                
                // 计算波浪效果
                float elevation = sin(position.x * frequency + time) * amplitude;
                elevation += sin(position.y * frequency + time) * amplitude;
                
                // 保存高度值传递给片元着色器
                vElevation = elevation;
                
                // 应用波浪效果到顶点位置
                vec3 newPosition = position + normal * elevation;
                
                // 计算最终位置
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `;
        
        // 波浪效果片元着色器
        const waveFragmentShader = `
            uniform vec3 colorA;
            uniform vec3 colorB;
            
            varying vec2 vUv;
            varying float vElevation;
            
            void main() {
                // 根据高度值混合两种颜色
                float mixFactor = (vElevation + 0.1) * 5.0;
                vec3 color = mix(colorA, colorB, mixFactor);
                
                // 设置最终颜色
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // 渐变效果顶点着色器
        const gradientVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            
            void main() {
                // 传递UV坐标和法线给片元着色器
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                
                // 计算最终位置
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        // 渐变效果片元着色器
        const gradientFragmentShader = `
            uniform vec3 colorA;
            uniform vec3 colorB;
            uniform float time;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            
            void main() {
                // 创建动态渐变效果
                float mixFactor = sin(vUv.y * 10.0 + time) * 0.5 + 0.5;
                vec3 color = mix(colorA, colorB, mixFactor);
                
                // 添加简单的光照效果
                float light = dot(vNormal, normalize(vec3(1.0, 1.0, 1.0)));
                light = 0.5 + 0.5 * light; // 将范围从[-1,1]映射到[0,1]
                
                // 应用光照
                color *= light;
                
                // 设置最终颜色
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // 脉冲效果顶点着色器
        const pulseVertexShader = `
            uniform float time;
            uniform float amplitude;
            uniform float frequency;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            
            void main() {
                // 传递UV坐标和法线给片元着色器
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                
                // 计算脉冲效果
                float pulse = sin(time * frequency) * amplitude;
                vec3 newPosition = position * (1.0 + pulse);
                
                // 计算最终位置
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `;
        
        // 脉冲效果片元着色器
        const pulseFragmentShader = `
            uniform vec3 colorA;
            uniform vec3 colorB;
            uniform float time;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            
            void main() {
                // 创建脉冲颜色效果
                float pulse = sin(time * 2.0) * 0.5 + 0.5;
                vec3 color = mix(colorA, colorB, pulse);
                
                // 添加简单的光照效果
                float light = dot(vNormal, normalize(vec3(1.0, 1.0, 1.0)));
                light = 0.5 + 0.5 * light; // 将范围从[-1,1]映射到[0,1]
                
                // 应用光照
                color *= light;
                
                // 设置最终颜色
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        /**
         * 初始化Three.js场景、相机、渲染器和控制器
         * 这是整个应用的入口点
         */
        function init() {
            // 创建场景 - 所有3D对象的容器
            window.scene = new THREE.Scene();
            // 设置场景背景色为深蓝灰色
            window.scene.background = new THREE.Color(0x2c3e50);
            
            // 创建透视相机 - 模拟人眼视角
            // 参数：视场角(FOV)，宽高比，近裁剪面，远裁剪面
            window.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // 设置相机位置，以便能看到场景中的对象
            window.camera.position.z = 3;
            
            // 创建WebGL渲染器 - 将3D场景渲染到canvas上
            window.renderer = new THREE.WebGLRenderer({ antialias: true }); // 启用抗锯齿
            // 设置渲染器尺寸为窗口大小
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            // 设置设备像素比，提高在高DPI设备上的清晰度
            window.renderer.setPixelRatio(window.devicePixelRatio);
            // 将渲染器的canvas添加到DOM中
            document.getElementById('threeContainer').appendChild(window.renderer.domElement);
            
            // 添加轨道控制器 - 允许用户交互式旋转和缩放场景
            controls = new OrbitControls(window.camera, window.renderer.domElement);
            controls.enableDamping = true;       // 启用阻尼效果，使控制更平滑
            controls.dampingFactor = 0.05;       // 阻尼系数
            controls.autoRotate = params.autoRotate; // 设置是否自动旋转
            
            // 创建时钟对象 - 用于动画
            clock = new THREE.Clock();
            
            // 创建3D对象
            createMesh();
            
            // 初始化GUI控制面板
            initGUI();
            
            // 监听窗口大小变化，调整场景
            window.addEventListener('resize', onWindowResize);
            
            // 开始动画循环
            animate();
        }
        
        /**
         * 处理窗口大小变化
         * 调整相机和渲染器以适应新的窗口尺寸
         */
        function onWindowResize() {
            // 更新相机宽高比
            window.camera.aspect = window.innerWidth / window.innerHeight;
            // 更新相机投影矩阵
            window.camera.updateProjectionMatrix();
            // 更新渲染器尺寸
            window.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        /**
         * 创建3D网格对象
         * 根据当前参数创建或更新3D对象
         */
        function createMesh() {
            // 如果已存在网格对象，则从场景中移除并释放资源
            if (mesh) {
                scene.remove(mesh);
                // 释放几何体和材质的内存，避免内存泄漏
                mesh.geometry.dispose();
                mesh.material.dispose();
            }
            
            // 根据选择的几何体类型创建几何体
            let geometry;
            switch (params.geometry) {
                case 'sphere':
                    geometry = new THREE.SphereGeometry(params.radius, params.segments, params.segments);
                    break;
                case 'box':
                    geometry = new THREE.BoxGeometry(
                        params.radius * 2, 
                        params.radius * 2, 
                        params.radius * 2, 
                        params.segments / 2, 
                        params.segments / 2, 
                        params.segments / 2
                    );
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(
                        params.radius, 
                        params.radius / 3, 
                        params.segments / 2, 
                        params.segments
                    );
                    break;
                case 'plane':
                    geometry = new THREE.PlaneGeometry(
                        params.radius * 2, 
                        params.radius * 2, 
                        params.segments, 
                        params.segments
                    );
                    break;
                default:
                    geometry = new THREE.SphereGeometry(params.radius, params.segments, params.segments);
            }
            
            // 解析颜色字符串为THREE.Color对象
            const colorA = new THREE.Color(params.colorA);
            const colorB = new THREE.Color(params.colorB);
            
            // 根据选择的着色器类型选择顶点和片元着色器
            let vertexShader, fragmentShader;
            switch (params.shaderType) {
                case 'wave':
                    vertexShader = waveVertexShader;
                    fragmentShader = waveFragmentShader;
                    break;
                case 'gradient':
                    vertexShader = gradientVertexShader;
                    fragmentShader = gradientFragmentShader;
                    break;
                case 'pulse':
                    vertexShader = pulseVertexShader;
                    fragmentShader = pulseFragmentShader;
                    break;
                default:
                    vertexShader = waveVertexShader;
                    fragmentShader = waveFragmentShader;
            }
            
            // 创建着色器材质
            // ShaderMaterial与RawShaderMaterial的区别在于，ShaderMaterial自动包含Three.js的内置变量和属性
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    colorA: { value: new THREE.Vector3(colorA.r, colorA.g, colorA.b) },
                    colorB: { value: new THREE.Vector3(colorB.r, colorB.g, colorB.b) },
                    amplitude: { value: params.amplitude },
                    frequency: { value: params.frequency }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                wireframe: params.wireframe
            });
            
            // 创建网格 - 将几何体和材质结合
            mesh = new THREE.Mesh(geometry, material);
            // 将网格添加到场景中
            scene.add(mesh);
        }
        
        /**
         * 初始化GUI控制面板
         * 创建用户可交互的控制界面，用于调整参数
         */
        function initGUI() {
            // 创建GUI实例
            const gui = new GUI({ title: '参数控制面板', width: 300 });
            
            // 调整GUI位置，避免与其他UI元素重叠
            gui.domElement.style.position = 'absolute';
            gui.domElement.style.top = '60px';
            gui.domElement.style.right = '10px';
            
            // 确保GUI在所有环境下都可见
            gui.domElement.style.zIndex = '1000';
            gui.domElement.style.maxHeight = '80vh'; // 限制最大高度
            gui.domElement.style.overflowY = 'auto'; // 允许垂直滚动
            
            // 确保GUI在页面加载后立即可见
            setTimeout(() => {
                gui.show();
                // 强制更新GUI
                for (const controller of gui.controllers) {
                    controller.updateDisplay();
                }
            }, 100);
            
            // 几何体参数控制组
            const geometryFolder = gui.addFolder('几何体参数');
            // 添加几何体类型选择
            geometryFolder.add(params, 'geometry', ['sphere', 'box', 'torus', 'plane'])
                .onChange(createMesh)
                .name('几何体类型');
            // 添加半径滑块
            geometryFolder.add(params, 'radius', 0.5, 2)
                .onChange(createMesh)
                .name('半径');
            // 添加分段数滑块
            geometryFolder.add(params, 'segments', 8, 128)
                .step(1)
                .onChange(createMesh)
                .name('分段数');
            // 默认展开此文件夹
            geometryFolder.open();
            
            // 着色器参数控制组
            const shaderFolder = gui.addFolder('着色器参数');
            // 添加着色器类型选择
            shaderFolder.add(params, 'shaderType', ['wave', 'gradient', 'pulse'])
                .onChange(createMesh)
                .name('着色器类型');
            // 添加振幅滑块
            shaderFolder.add(params, 'amplitude', 0, 0.5)
                .onChange(value => {
                    if (mesh && mesh.material.uniforms) {
                        mesh.material.uniforms.amplitude.value = value;
                    }
                })
                .name('振幅');
            // 添加频率滑块
            shaderFolder.add(params, 'frequency', 0.1, 10)
                .onChange(value => {
                    if (mesh && mesh.material.uniforms) {
                        mesh.material.uniforms.frequency.value = value;
                    }
                })
                .name('频率');
            // 添加速度滑块
            shaderFolder.add(params, 'speed', 0, 5)
                .name('动画速度');
            // 添加颜色A选择器
            shaderFolder.addColor(params, 'colorA')
                .onChange(value => {
                    const color = new THREE.Color(value);
                    if (mesh && mesh.material.uniforms) {
                        mesh.material.uniforms.colorA.value.set(color.r, color.g, color.b);
                    }
                })
                .name('颜色A');
            // 添加颜色B选择器
            shaderFolder.addColor(params, 'colorB')
                .onChange(value => {
                    const color = new THREE.Color(value);
                    if (mesh && mesh.material.uniforms) {
                        mesh.material.uniforms.colorB.value.set(color.r, color.g, color.b);
                    }
                })
                .name('颜色B');
            // 添加线框模式切换
            shaderFolder.add(params, 'wireframe')
                .onChange(value => {
                    if (mesh) {
                        mesh.material.wireframe = value;
                    }
                })
                .name('线框模式');
            // 默认展开此文件夹
            shaderFolder.open();
            
            // 控制器参数控制组
            const controlsFolder = gui.addFolder('控制器参数');
            // 添加自动旋转切换
            controlsFolder.add(params, 'autoRotate')
                .name('自动旋转')
                .onChange(value => {
                    controls.autoRotate = value;
                });
            // 默认展开此文件夹
            controlsFolder.open();
        }
        
        /**
         * 动画循环函数
         * 使用requestAnimationFrame实现平滑动画
         * 每帧更新场景并渲染
         */
        function animate() {
            // 请求下一帧动画
            requestAnimationFrame(animate);
            
            // 更新轨道控制器
            // 如果启用了阻尼效果，需要在每帧调用update
            controls.update();
            
            // 更新着色器中的时间统一变量
            if (mesh && mesh.material.uniforms) {
                // 获取经过的时间并乘以速度参数
                mesh.material.uniforms.time.value = clock.getElapsedTime() * params.speed;
            }
            
            // 渲染场景
            window.renderer.render(window.scene, window.camera);
        }
        
        // 初始化应用
        init();
    </script>
    
    <!-- 
    ===================================================
    截图功能脚本 - 请勿修改此部分
    此脚本处理从父窗口发来的截图请求，用于生成示例封面，与示例业务并无关联
    ===================================================
    -->
    <script>
        // 全局变量，用于存储渲染器引用
        let _screenshotRenderer;
        
        // 添加消息监听器，处理截图请求
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'take-screenshot') {
                try {
                    // 获取当前渲染器
                    if (!_screenshotRenderer && window.renderer) {
                        _screenshotRenderer = window.renderer;
                    }
                    
                    // 确保渲染器已经初始化
                    if (!_screenshotRenderer) {
                        throw new Error('渲染器未初始化');
                    }
                    
                    // 强制渲染一帧，确保内容是最新的
                    if (window.scene && window.camera) {
                        _screenshotRenderer.render(window.scene, window.camera);
                    }
                    
                    // 获取canvas的图像数据（使用较低的质量和尺寸以减小文件大小）
                    const quality = event.data.quality || 0.8;
                    const canvas = _screenshotRenderer.domElement;
                    
                    // 创建一个较小尺寸的临时canvas
                    const tempCanvas = document.createElement('canvas');
                    const maxSize = 600; // 最大尺寸为600像素
                    
                    // 计算缩放比例，保持宽高比
                    const scale = Math.min(maxSize / canvas.width, maxSize / canvas.height);
                    tempCanvas.width = Math.floor(canvas.width * scale);
                    tempCanvas.height = Math.floor(canvas.height * scale);
                    
                    // 在临时canvas上绘制缩小的图像
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // 获取缩小后的图像数据
                    const dataUrl = tempCanvas.toDataURL('image/jpeg', quality);
                    
                    // 将图像数据发送回父窗口
                    window.parent.postMessage({
                        type: 'screenshot-data',
                        dataUrl: dataUrl
                    }, '*');
                } catch (error) {
                    console.error('截图失败:', error);
                    // 发送错误信息回父窗口
                    window.parent.postMessage({
                        type: 'screenshot-error',
                        error: error.message
                    }, '*');
                }
            }
        });
    </script>
</body>
</html>